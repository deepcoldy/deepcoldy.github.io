webpackJsonp([31264433167884],{441:function(e,p){e.exports={data:{site:{siteMetadata:{title:"DeepCold Blog",author:"DeepCold"}},markdownRemark:{id:"/Users/80253170/iserver/deepcoldy.github.io/src/pages/older/2015-09-15.md absPath of file >>> MarkdownRemark",html:'<p><strong>首先了解一下em是何物？</strong></p>\n<p>em指字体高，任意浏览器的默认字体高都是16px。所以未经调整的浏览器都符合: 1em=16px。那么12px=0.75em, 10px=0.625em。为了简化font -size的换算，需要在css中的body选择器中声明Font-size=62.5%，这就使em值变为16px*62.5%=10px, 这样12px=1.2em, 10px=1em, 也就是说只需要将你的原来的px数值除以10，然后换上em作为单位就行了。</p>\n<p>em有如下特点：</p>\n<ol>\n<li>\n<p>em的值并不是固定的；</p>\n</li>\n<li>\n<p>em会继承父级元素的字体大小。</p>\n</li>\n</ol>\n<p><strong>重写步骤：</strong></p>\n<ol>\n<li>\n<p>body选择器中声明Font-size:62.5%；</p>\n</li>\n<li>\n<p>将你的原来的px数值除以10，然后换上em作为单位；</p>\n</li>\n</ol>\n<p>简单吧，如果只需要以上两步就能解决问题的话，可能就没人用px了。经过以上两步，你会发现你的网站字体大得出乎想象。因为em的值不固定，又会继承父级 元素的大小，你可能会在content这个div里把字体大小设为1.2em, 也就是12px。然后你又把选择器p的字体大小也设为1.2em，但如果p属于content的子级的话，p的字体大小就不是12px，而是1.2em= 1.2* 12px=14.4px。这是因为content的字体大小被设为1.2em，这个em值继承其父级元素body的大小，也就是16px * 62.5% * 1.2=12px, 而p作为其子级，em则继承content的字体高，也就是12px。所以p的1.2em就不再是12px，而是14.4px。</p>\n<ol start="3">\n<li>重新计算那些被放大的字体的em数值。避免字体大小的重复声明，也就是避免以上提到的1.2 * 1.2= 1.44的现象。比如说你在#main中声明了字体大小为1.2em，那么在声明p的字体大小时就只能是1em，而不是1.2em, 因为此em非彼em，它因继承#content的字体高而变为了1em=12px。</li>\n</ol>\n<p><strong>诡异的12px汉字</strong></p>\n<p>在完成em转换时还会发现一个诡异的现象，就是由以上方法得到的12px(1.2em)大小的汉字在IE中并不等于直接用12px定义的字体大小，而 是稍大一点。这个问题我已经解决，你只需在body选择器中把62.5%换成63%就能正常显示了。</p>',frontmatter:{title:"css中em px",date:"September 15, 2015"}}},pathContext:{slug:"/older/2015-09-15/",previous:{fields:{slug:"/older/2015-09-12/"},frontmatter:{title:"随便写个轮播的滚动效果"}},next:{fields:{slug:"/older/2015-09-17/"},frontmatter:{title:"Angular Js（第一章）"}}}}}});
//# sourceMappingURL=path---older-2015-09-15-96be65325a42ad14e0ce.js.map