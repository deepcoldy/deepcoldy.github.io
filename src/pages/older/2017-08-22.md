---
date: 2017-08-22 16:05:55
status: public
title: 使用WEBHOOK+NODEJS将GIT项目代码自动部署服务器-进阶版
---

续上篇：[使用WEBHOOK+NODEJS将GIT项目代码自动部署服务器](https://blog.iscode.cn/post/jing-yan-zong-jie/shi-yong-webhook-nodejsjiang-dai-ma-zi-dong-bu-shu-fu-wu-qi)

##前言
上篇讲到，根据判断文件路径是否有git pull的方式来判断是否需要重新build项目，但是这样会遇到一些问题，比如：有时候路径过长，shell中可能会自动隐藏一部分文件路径，这样就不能触发build了。
针对这种情况，我来改进一下webhook.js。
##开工
之前引入的模块不变，在此基础上增加了[chokidar](https://github.com/paulmillr/chokidar)这个模块，能很好的监听文件的变化。
```js
var http = require('http')
var createHandler = require('node-gitlab-webhook')
var spawn = require('child_process').spawn
```
为什么使用chokidar而不使用node自带的fs.watch呢？chokidar官方文档很好的回答了这个问题。
![](http://ac-HSNl7zbI.clouddn.com/4bxDRUJvPsjw8j4U3fWM0Gr1kKYRa4D1PL2FV9te.jpg)
##结合chokidar
`chokidar.watch`方法定义了监听的路径。
on方法可以传入两个参数，第一个是监听文件变化的类型，第二个是回调Function。我这边肯定是有变化我就要重新build，所以第一个参数是all。
```js
let push_event = false
chokidar.watch('/iserver/wx_weiche/vue/src/').on('all', (event, path) => {
  setTimeout(()=>{
    console.log(event, path)
    if(push_event){ //每次pull只会进入一次
      console.log('vue project building...')
      push_event = false
      rumCommand('sh', ['./build.sh'], txt => {
        console.log(txt)
      })
    }
  },3000)
})
handler.on('push', function (event) {
  console.log(
    'Received a push event for %s',
    event.payload.repository.name
  )
  switch(event.path) {
    case '/push':
      rumCommand('sh', ['./pull.sh'], txt => {
        push_event = true //每次git pull操作会打开push_event开关 
        console.log(txt)
      })
      break
  }
})
```
可以注意到回调函数里我加了一个setTimeout，这边是为了延迟build的操作，因为当git pull受网络因素和人为因素的影响完成并不会非常及时。
另外我认为一次pull只需要执行一次build操作，那么我在pull的时候设置`push_event = true`，在chokidar的回调中来判断是否已经有build命令在执行了。
##完整代码
```js
var http = require('http')
var createHandler = require('node-gitlab-webhook')
var spawn = require('child_process').spawn
var handler = createHandler([ // multiple handlers
  { path: '/push' }
])

http.createServer(function (req, res) {
  handler(req, res, function (err) {
    res.statusCode = 404
    res.end('no such location test')
  })
}).listen(7777)

handler.on('error', function (err) {
  console.error('Error:', err.message)
})

const rumCommand = (cmd, args, callback) => {
  const child = spawn(cmd, args)
  let response = ''
  child.stdout.on('data', buffer => response += buffer.toString())
  child.stdout.on('end', () => callback(response))
}

var chokidar = require('chokidar')
let push_event = false

chokidar.watch('/iserver/wx_weiche/vue/src/').on('all', (event, path) => {
  setTimeout(()=>{
    console.log(event, path)
    if(push_event){
      console.log('vue project building...')
      push_event = false
      rumCommand('sh', ['./build.sh'], txt => {
        console.log(txt)
      })
    }
  },3000)
})
handler.on('push', function (event) {
  console.log(
    'Received a push event for %s',
    event.payload.repository.name
  )
  switch(event.path) {
    case '/push':
      rumCommand('sh', ['./pull.sh'], txt => {
        push_event = true
        console.log(txt)
      })
      break
  }
})
```
至此该工具也就开发的差不多，在我们的测试环境已经运行了很久了，不仅节省了我们的修复Bug的时间，也更加省心避免了误操作的可能。

##后期优化的可能
作为一个测试服务器的自动build工具，已经足够使用了，然而思考到如何才能进一步提升测试效率，想到可以在测试服务器同本地开发环境一样使用hot reload的形式，但是这样可能会涉及到跟build出来的文件不一致的问题，暂时还没有想到更好的思路，如果看到此的你有更好的方法拜托请指出，多谢了~
