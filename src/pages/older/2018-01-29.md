---
date: 2018-01-29 00:00:00
status: public
title: preact
---

下午抽了一个小时时间来研究了一下Preact，发现此框架对于理解React有非常好的借鉴作用。


## 如何理解Preact

众所周知，Preact沿用了JSX和虚拟dom。

我们写JSX：

```js
/** @jsx h */
let foo = <div id="foo">Hello!</div>;  
```

会被编译成如下执行：

```js
var foo = h('div', {id:"foo"}, 'Hello!');  
```

这个编译过程是由[babel-plugin-transform-react-jsx](https://github.com/babel/babel/tree/master/packages/babel-plugin-transform-react-jsx)来完成的。babel-plugin-transform-react-jsx这个插件读取jsx文件中的`/** @jsx XXX */`来决定使用哪个pragma来编译。如果是Preact则会使用其h()函数。

h函数简单概括如下：

```js
function h(nodeName, attributes, ...args) {
	let children = args.length ? [].concat(...args) : null;
	return { nodeName, attributes, children };
}
```

可以理解为就是一个虚拟dom解析为dom Node的过程。
可见，`h()`的执行需要如下解构：

```js
{
  nodeName: "div",
  attributes: {
    "id": "foo"
  },
  children: ["Hello!"]
}
```

那么nodeName、attributes又是哪里来的呢？就是render函数。

```js
function render(vnode) { // vnode即jsx
    // 字符串转化为text Nodes:
    if (vnode.split) return document.createTextNode(vnode);

    // 用我们的VDOM元素的nodeName创建一个DOM元素
    let n = document.createElement(vnode.nodeName);

    // 将attribute赋值给新的node节点
    let a = vnode.attributes || {};
    Object.keys(a).forEach( k => n.setAttribute(k, a[k]) );

    // 将子元素append上去
    (vnode.children || []).forEach( c => n.appendChild(render(c)) );

    return n;
}

```

最后运行render函数把定义的jsx传入。

```js
render(vdom);
```

就这么简单，逻辑就通了。



## React 与 Preact Api的差异

[参见文档](https://preactjs.com/guide/differences-to-react)

## 参考文献

[wtf-is-jsx](https://jasonformat.com/wtf-is-jsx/)

