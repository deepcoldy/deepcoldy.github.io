---
date: 2018-09-28
status: public
title: 小程序页面堆栈的Hack(含源码)
---

小程序在页面堆栈达到10层时将会触发Error。
但是当产品又设计出一款页面带有循环跳转的产品时，我们不得不去Hack掉小程序的官方限制。

下面我将基于Taro作为小程序框架，继承小程序api的情况下，写一下如何Hack比较好。


```js
// 文件路径：util/router.js

import Taro from '@tarojs/taro';

class Router {
  stack = ['/pages/index/index']; // 页面堆栈储存
  navigateTo = obj => {
    this.stack.push(obj.url);
    if (this.stack.length <= 8) {
      Taro.navigateTo(obj);
    } else if (this.stack.length === 9) { // 当页面层级达到9层时，跳转中转页
      Taro.navigateTo({
        ...obj,
        url: `/pages/stack/index?next=${encodeURIComponent(obj.url)}`
      });
    } else {
      const saveToStack = true;
      this.redirectTo(obj, saveToStack);
    }
  };
  redirectTo = (obj, saveToStack = false) => {
    if (!saveToStack) {
      this.stack[this.stack.length - 1] = obj.url;
    }
    Taro.redirectTo(obj);
  };
  navigateBack = obj => {
    this.stack.splice(-obj.delta);
    Taro.navigateBack(obj);
  };
  switchTab = obj => {
    this.stack = ['/pages/index/index']; // 当使用了小程序官方的tabbar时
    Taro.switchTab(obj);
  };
}
const router = new Router();
export default router;

```

页面文件如下，记得在app.js中写入路径`pages/stack/index`

```js
// 文件路径：src/stack.js

import Taro, { Component } from '@tarojs/taro';
import { View } from '@tarojs/components';
import { AtActivityIndicator } from 'taro-ui'; // 使用Taro-ui的Indicator作为loading

import Router from '../../util/router';

import './index.scss';

class Stack extends Component {
  config = {
    navigationBarTitleText: ''
  };
  first = true;
  componentDidMount() {
    // 初次进入，执行
    if (Router.stack.length === 9) {
      Taro.navigateTo({
        url: decodeURIComponent(this.$router.params.next)
      });
      this.first = false;
    }
  }
  componentDidShow() {
    // 由其他页面后退进入，执行
    if (Router.stack.length === 9 && !this.first) {
      Router.stack.splice(-1);
      Router.navigateBack({
        delta: 1
      });
    } else if (Router.stack.length > 9) {
      Router.stack.splice(-1);
      Taro.navigateTo({
        url: Router.stack.slice(-1)[0]
      });
    }
  }
  render() {
    return (
      <View className='stack-page'>
        <AtActivityIndicator mode='center' />
      </View>
    );
  }
}

export default Stack;

```

使用方法：

```js



import Router from '../../util/router';
class Index extends Component {

  navigateTo = () => {
    Taro.navigateTo({
      url: '/pages/other/index'
    })
  }
  rediectTo = () => {
    Taro.rediectTo({
      url: '/pages/other/index'
    })
  }
  navigateBack = () => {
    Taro.navigateBack({
      delta: 1
    })
  }
  switchTab = () => {
    Taro.switchTab({
      url: '/pages/other/index'
    })
  }
  

  render() {
    return (
      <View className='index-page'>
        
      </View>
    );
  }
}

export default Index;

```

Hack之后的效果为，当页面堆栈数达到8层时，再次执行跳转将打开中转页(第九层)，跳转到所需页面（第十层）。
之后的跳转变成在第十层的redirect。
点返回会返回中转页（第九层）。
再由中转页判断堆栈是否需要前进还是后退。

注意：由于小程序自带的左上角返回没有提供监听事件。
两种方式：1.在页面onHide时，减少堆栈。
2.自定义左上角返回，改用router.js的navigateBack函数。